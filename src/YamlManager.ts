import { readdirSync, readFileSync } from "fs";
import { readdir, readFile, unlink, writeFile } from "fs/promises";
import { basename, join as pathJoin, sep as pathSep } from "path";

import {
  User as DiscordUser,
  Client as DiscordClient,
  Interaction as DiscordInteraction,
  Message as DiscordMessage,
  CommandInteraction,
  ActionRowBuilder,
  ButtonBuilder,
  EmbedBuilder,
  StringSelectMenuBuilder,
  StringSelectMenuOptionBuilder,
  InteractionUpdateOptions,
  ButtonStyle,
  MessageType,
  userMention,
} from "discord.js";
import { Op as SqlOp } from "sequelize";
import * as YAML from "yaml";

import {
  GetFile,
  QuickValidateYaml,
  MkdirIfNotExist,
  GenerateLetterCode,
  YamlData,
  GameFunctionState,
  GetGameFunctionState,
  GetStdFunctionStateErrorMsg,
  VersionSpec,
} from "./core";
import { PlayerTable, YamlTable } from "./Sequelize";

/** The result of the YAML listener. */
export interface YamlListenerResult {
  /**
   * The reason the YAML listener terminated. Reasons generated by the listener include:
   *
   * `gotyaml`: At least one valid YAML was received.
   *
   * `yamlerror`: No vaild YAMLs were received, and at least one invalid YAML was received.
   *
   * `notyaml`: A file was received that wasn't a YAML.
   *
   * `time`: The operation timed out.
   *
   * Any other reason is returned as a result of calling {@link YamlListenerReturn.terminate}.
   */
  reason: string;
  /**
   * If the {@link reason} is `gotyaml`, the list of received valid YAMLs.
   * If it is `yamlerror`, the list of received invalid YAMLs.
   * Otherwise, should be empty.
   */
  retval: YamlData[];

  /** The user who sent the YAML. */
  user: DiscordUser | null;
}

/** The return value for {@link YamlManager.YamlListener}. */
export interface YamlListenerReturn {
  /** A promise which resolves as the {@link YamlListenerResult} of the YAML listener. */
  result: Promise<YamlListenerResult>;
  /**
   * A callback function which will terminate the YAML listener.
   * @param reason The reason the YAML listener is terminating, if any.
   */
  terminate: (reason?: string) => void;
}

export class YamlManager {
  /** The Discord API client interface. */
  private readonly _client: DiscordClient;
  /** The user to which this YAML manager pertains. */
  private readonly _user: DiscordUser;
  /** The path to the user's YAMLs. */
  public readonly yamlPath: string;

  /** The client's user ID, if it is available. If not, returns an empty string. */
  public get clientId() {
    return this._client && this._client.user ? this._client.user.id : "";
  }
  /** The user to which this YAML manager pertains. */
  public get userId() {
    return this._user.id;
  }

  public constructor(client: DiscordClient, userId: string) {
    this._client = client;
    const user = this._client.users.cache.get(userId);
    if (!user) throw new Error(`User ${userId} not found`);
    this._user = user;
    this.yamlPath = pathJoin("yamls", user.id);
  }

  /**
   * Opens a YAML manager session for this user.
   * @async
   */
  public async YamlManager() {
    let curEntry: YamlTable | null = null;

    const generateCurEntryEmbed = async (/*calledUser?: string*/) => {
      if (!curEntry) return [];
      else
        return [
          new EmbedBuilder({
            title: curEntry.description ?? "Unknown",
            //footer: { text: userMention(calledUser ?? curEntry.userId) },
            fields: [
              {
                name: "Games",
                value: curEntry.games.join(", ") ?? "Unknown",
              },
              {
                name: "User",
                value: userMention(curEntry.userId),
                inline: true,
              },
              {
                name: "AP ver",
                value:
                  (await YamlManager.GetYamlVersionByCode(curEntry.code))?.join(
                    "."
                  ) ?? "Unknown",
                inline: true,
              },
            ],
            timestamp: curEntry.updatedAt.toISOString(),
          }),
        ];
    };

    /** A component row containing a YAML dropdown box. */
    const yamlRow =
      new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(
        new StringSelectMenuBuilder({
          customId: "yaml",
          placeholder: "Select a YAML",
          options: (await this.GetYamlOptionsV3([])).map((i) => i.toJSON()),
        })
      );
    /** A component row containing buttons to manage individual YAMLs. */
    const buttonRow = new ActionRowBuilder<ButtonBuilder>().addComponents(
      new ButtonBuilder({
        customId: "backToYamlList",
        label: "Back",
        style: ButtonStyle.Secondary,
      }),
      new ButtonBuilder({
        customId: "setDefaultYaml",
        label: "Set Default",
        style: ButtonStyle.Primary,
      }),
      new ButtonBuilder({
        customId: "deleteYaml",
        label: "Delete",
        style: ButtonStyle.Danger,
      })
    );
    /** The default starting state of the YAML manager. */
    const startingState = {
      content:
        "You can reply to this message with a YAML to add it, or select one from the list to act on it.",
      embeds: [],
      components: [yamlRow],
      files: [],
    };

    /** The message that will be controlled to represent the YAML management interface. */
    const msg = await this._user.send(startingState);

    let { result, terminate } = await YamlManager.YamlListener(msg);

    const subInteractionHandler = async (subInt: DiscordInteraction) => {
      if (!subInt.isStringSelectMenu() && !subInt.isButton()) return;
      if (subInt.user.id !== this.userId) return;
      if (subInt.message.id !== msg.id) return;

      if (subInt.isStringSelectMenu()) {
        if (subInt.values[0] === "noyaml")
          subInt.update({
            content:
              "There are no YAMLs currently associated to you. Please provide one by replying to this message with it attached.",
          });
        else {
          curEntry = await YamlTable.findByPk(subInt.values[0]);

          if (!curEntry) {
            subInt.update(startingState);
          } else {
            const playerEntry = await PlayerTable.findByPk(this.userId);
            const worstState = YamlManager.GetWorstStatus(curEntry.games);
            (buttonRow.components[1] as ButtonBuilder).setDisabled(
              worstState > GameFunctionState.Playable ||
                playerEntry?.defaultCode === curEntry.code
            );
            subInt.update({
              content:
                "You can update the selected YAML by replying to this message with a new one. You can also set it as default for sync runs, or delete it.",
              embeds: await generateCurEntryEmbed(/*subInt.user.id*/),
              components: [buttonRow],
              files: [
                {
                  attachment: readFileSync(
                    pathJoin(this.yamlPath, `${curEntry.filename}.yaml`)
                  ),
                  name: `${this._user.username}-${curEntry.updatedAt
                    .toISOString()
                    .substring(0, 10)}.yaml`,
                },
              ],
            });
          }
        }
      } else if (subInt.isButton() && curEntry) {
        switch (subInt.customId) {
          case "backToYamlList":
            curEntry = null;
            subInt.update(startingState);
            break;

          case "setDefaultYaml":
            {
              const worstStatus = YamlManager.GetWorstStatus(curEntry.games);
              if (worstStatus === GameFunctionState.Playable) {
                await PlayerTable.update(
                  { defaultCode: curEntry.code },
                  {
                    where: { userId: curEntry.userId },
                  }
                );

                (buttonRow.components[1] as ButtonBuilder).setDisabled(true);
                (yamlRow.components[0] as StringSelectMenuBuilder).setOptions(
                  await this.GetYamlOptionsV3([])
                );
                subInt.update({
                  content: "Your default YAML has been changed to this one.",
                  components: [buttonRow],
                });
              } else
                subInt.update({
                  content: GetStdFunctionStateErrorMsg(
                    worstStatus,
                    "as your default YAML"
                  ),
                });
            }
            break;

          case "deleteYaml":
            subInt.update({
              content: "Are you sure you wish to delete this YAML?",
              components: [
                new ActionRowBuilder<ButtonBuilder>().addComponents(
                  new ButtonBuilder({
                    customId: "deleteYamlYes",
                    label: "Yes",
                    style: ButtonStyle.Danger,
                  }),
                  new ButtonBuilder({
                    customId: "deleteYamlNo",
                    label: "No",
                    style: ButtonStyle.Secondary,
                  })
                ),
              ],
            });
            break;

          case "deleteYamlYes":
            await YamlTable.destroy({ where: { code: curEntry.code } });

            await Promise.all([
              PlayerTable.update(
                { defaultCode: null },
                { where: { defaultCode: curEntry.code } }
              ),
              unlink(pathJoin(this.yamlPath, `${curEntry.filename}.yaml`)),
            ]);

            (yamlRow.components[0] as StringSelectMenuBuilder).setOptions(
              await this.GetYamlOptionsV3([])
            );
            curEntry = null;
            subInt.update(
              Object.assign<
                InteractionUpdateOptions,
                InteractionUpdateOptions,
                InteractionUpdateOptions
              >({}, startingState, {
                content:
                  "The YAML has been deleted. You can now add more if you wish, or manage any remaining YAMLs.",
                files: [],
                embeds: [],
              })
            );
            break;

          case "deleteYamlNo":
            subInt.update({
              content:
                "You can update the selected YAML by replying to this message with a new one. You can also set it as default for sync runs, or delete it.",
              components: [buttonRow],
            });
            break;

          default:
            console.debug(subInt);
            subInt.update({
              content: `You clicked the ${subInt.customId} button! (Apparently I don't know what that means.)`,
            });
            break;
        }
      }
    };

    this._client.on("interactionCreate", subInteractionHandler);

    let timeoutSignal: NodeJS.Timeout;
    const Timeout = () => {
      terminate("time");
    };
    const ResetTimeout = (msec = 180000) => {
      if (timeoutSignal) clearTimeout(timeoutSignal);
      timeoutSignal = setTimeout(Timeout, msec);
    };

    const RefreshCollector = () => {
      ResetTimeout();
      YamlManager.YamlListener(msg).then((i) => {
        ({ result, terminate } = i);
        result.then(resultThen);
      });
    };
    const resultThen = async ({ retval, reason }: YamlListenerResult) => {
      if (["gotyaml", "notyaml", "yamlerror"].includes(reason))
        RefreshCollector();
      switch (reason) {
        case "gotyaml":
          if (curEntry) {
            await this.UpdateYaml(curEntry.code, retval[0]);
            curEntry = await YamlTable.findByPk(curEntry.code);
            (yamlRow.components[0] as StringSelectMenuBuilder).setOptions(
              await this.GetYamlOptionsV3([])
            );
            msg.edit({
              content: `Thanks! YAML has been updated.`,
              embeds: await generateCurEntryEmbed(),
            });
          } else {
            await this.AddYamls(...retval);
            (yamlRow.components[0] as StringSelectMenuBuilder).setOptions(
              await this.GetYamlOptionsV3([])
            );
            msg.edit({
              content: `Thanks! Added ${retval.length} YAML(s) to your collection.`,
              components: [yamlRow],
            });
          }
          break;
        case "yamlerror":
          msg.edit({
            content: `There was a problem parsing YAMLs: ${retval[0].error}\nPlease review the error and try again.`,
          });
          break;
        case "notyaml":
          msg.edit({
            content:
              "That doesn't look like a valid YAML. Please check your submission and try again.",
          });
          break;
        default:
          if (reason === "time")
            msg.edit({
              content: "Timed out.",
              embeds: [],
              components: [],
              files: [],
            });
          this._client.off("interactionCreate", subInteractionHandler);
          console.debug(
            "Message collector for YAML manager for user %s#%s has been closed.",
            this._user.username,
            this._user.discriminator
          );
          break;
      }
    };

    result.then(resultThen);

    ResetTimeout();
  }

  /**
   * Adds one or more YAMLs to this player's collection.
   * @async
   * @param yamls The YAMLs to add to this player's collection.
   * @returns A promise that resolves when all YAMLs are added, as the four-letter codes for the YAMLs added.
   */
  public async AddYamls(...yamls: YamlData[]) {
    // TODO: check against existing yamls for user to prevent duplicates
    const existingCodes = (
      await YamlTable.findAll({
        attributes: ["code"],
      })
    ).map((i) => i.code);

    const retval: string[] = [];

    MkdirIfNotExist(this.yamlPath);
    for (const index in yamls) {
      const code = GenerateLetterCode([...existingCodes, ...retval]);

      const yaml = yamls[index];
      await Promise.all([
        writeFile(
          pathJoin(this.yamlPath, `${yaml.msgId}-${index}.yaml`),
          yaml.data
        ),
        YamlTable.create({
          code,
          userId: this.userId,
          filename: `${yaml.msgId}-${index}`,
          description: yaml.desc ?? "No description provided",
          games: yaml.games ?? ["A Link to the Past"],
          playerName: yaml.name ?? ["Who?"],
        }),
      ]);

      retval.push(code);
    }

    return retval;
  }

  /**
   * Updates a player's YAML.
   * @async
   * @param code The four-letter code for the YAML to update.
   * @param yaml The updated YAML data.
   * @returns A promise that resolves when the update operation completes.
   */
  public async UpdateYaml(code: string, yaml: YamlData) {
    const existingYaml = await YamlTable.findByPk(code);
    if (!existingYaml) throw new Error(`YAML ${code} not found`);
    if (existingYaml.userId !== this.userId)
      throw new Error(`YAML ${code} does not belong to this user`);

    await Promise.all([
      writeFile(pathJoin(this.yamlPath, `${yaml.msgId}-u.yaml`), yaml.data),
      YamlTable.update(
        {
          filename: `${yaml.msgId}-u`,
          description: yaml.desc ?? "No description provided",
          games: yaml.games ?? ["A Link to the Past"],
          playerName: yaml.name ?? ["Who?"],
        },
        {
          where: { code },
        }
      ),
    ]);

    return unlink(pathJoin(this.yamlPath, `${existingYaml.filename}.yaml`));
  }

  /**
   * Retrieves a list of the managed player's YAML options, to be used in a Discord drop-down box.
   * @async
   * @param validStates Optional. Determines which game states are pulled from the list. Defaults to {@link GameFunctionState.Playable}.
   * @returns {Promise<SelectMenuOptionBuilder[]>} A promise that resolves into the list of available YAMLs, in {@link SelectMenuOptionBuilder} form.
   */
  public async GetYamlOptionsV3(
    validStates: GameFunctionState[] = [GameFunctionState.Playable]
  ): Promise<StringSelectMenuOptionBuilder[]> {
    // BUG: more than 25 YAMLs breaks the dropdown
    const playerEntry =
      (await PlayerTable.findByPk(this.userId)) ??
      (await PlayerTable.create({ userId: this.userId, defaultCode: null }));
    const retval = await YamlTable.findAll({
      where: { userId: this.userId },
      order: [["updatedAt", "DESC"]],
    }).then((r) =>
      r
        .filter((i) =>
          validStates.length
            ? validStates.includes(YamlManager.GetWorstStatus(i.games))
            : true
        )
        .map((i) => {
          const emoji = YamlManager.GetEmoji(
            i.games,
            i.code === playerEntry.defaultCode
          );
          let games = i.games.join(", ");
          if (games.length > 100) games = games.substring(0, 97) + "…";
          return new StringSelectMenuOptionBuilder({
            label:
              i.description && i.description.length > 0
                ? i.description
                : "No description provided",
            description: games,
            value: i.code,
            emoji,
          });
        })
    );

    // HACK: truncate YAML list to last 25
    return (retval.length === 0
      ? [
          new StringSelectMenuOptionBuilder({
            label: "No YAMLs",
            value: "noyaml",
          }),
        ]
      : retval).slice(0, 25);
  }

  /**
   * Launches a message collector on a given message meant to receive YAML files.
   * @static
   * @async
   * @param msg The message to listen for responses to.
   * @param time Optional. How much time in milliseconds to listen for YAMLs.
   * @returns {Promise<YamlListenerReturn>} A promise that resolves into a set of features used to manage the listener further.
   */
  static async YamlListener(
    msg: DiscordMessage,
    time?: number
  ): Promise<YamlListenerReturn> {
    const msgCollector = msg.channel.createMessageCollector({
      filter: (msgIn) =>
        msgIn.type === MessageType.Reply &&
        msgIn.reference?.messageId === msg.id &&
        msgIn.attachments.size > 0,
      time,
    });

    let running = true;
    let user: DiscordUser | null = null;
    const retval: YamlData[] = [];
    const errors: YamlData[] = [];

    msgCollector.on("collect", (msgIn) => {
      user = msgIn.author;
      const yamls = msgIn.attachments.filter(
        (i) => i.url.endsWith(".yaml") || i.url.endsWith(".yml")
      );
      if (yamls.size === 0) msg.edit("That wasn't a YAML! Please try again.");
      else {
        Promise.all(yamls.map((i) => GetFile(i.url)))
          .then(async (yamlList) => {
            running = false;
            //console.debug(yamlList);
            for (const yamlStr of yamlList) {
              const validate = QuickValidateYaml(yamlStr);
              validate.msgId = msgIn.id;
              if (!validate.error) retval.push(validate);
              else errors.push(validate);
            }

            if (msgIn.deletable) msgIn.delete();
            else msgIn.react("👀");

            if (retval.length > 0) msgCollector.stop("gotyaml");
            else if (errors.length > 0) {
              retval.push(...errors);
              msgCollector.stop("yamlerror");
            } else msgCollector.stop("notyaml");
          })
          .catch((e) => {
            msg.edit("An error occurred. Check debug log.");
            console.error(e);
          });
      }
    });

    const result = new Promise<YamlListenerResult>((f) => {
      msgCollector.on("end", (_, reason) => {
        running = false;
        console.debug(
          reason === "gotyaml"
            ? "📫"
            : "📪" +
                ` YAML listener closed with code ${reason} on msg id ${msg.id}`
        );
        f({
          reason,
          retval,
          user,
        });
      });
    });

    const terminate = (reason?: string) => {
      if (running) msgCollector.stop(reason);
    };

    console.debug(`📭 YAML listener opened on msg id ${msg.id}`);

    return {
      result,
      terminate,
    };
  }

  /**
   * Retrieve a set of YAMLs by four-letter code.
   * @static
   * @async
   * @param codes The four-letter codes associated to the YAMLs to retrieve.
   * @returns A promise that resolves into the collection of database rows associated to the YAMLs requested.
   */
  static async GetYamlsByCode(...codes: string[]) {
    return YamlTable.findAll({
      attributes: ["code", "userId", "filename", "playerName"],
      where: { code: { [SqlOp.in]: codes } },
    });
  }

  /**
   * Cleans up the YAML database and file structure by removing orphaned entries.
   * @static
   * @async
   * @param interaction Optional. The interaction which called this function to be used.
   */
  static async CleanupYamls(interaction?: CommandInteraction) {
    const [yamlDb, yamlFiles] = await Promise.all([
      YamlTable.findAll().then((i) =>
        i.map((ii) => pathJoin("yamls", ii.userId, `${ii.filename}.yaml`))
      ),
      readdir("yamls", { withFileTypes: true }).then((yamlDir) =>
        yamlDir
          .filter((yamlUserDir) => yamlUserDir.isDirectory)
          .map((yamlUserDir) =>
            // TODO: redo this to use readdir promise
            readdirSync(pathJoin("yamls", yamlUserDir.name))
              .filter((yamlFile) => yamlFile.endsWith(".yaml"))
              .map((yamlFile) => pathJoin("yamls", yamlUserDir.name, yamlFile))
          )
          .flat()
      ),
    ]);
    /** The list of files that are in common between the database and the file store. */
    const yamlCommon = yamlDb.filter((i) => yamlFiles.includes(i));

    /** The number of database entries pruned. */
    const dbPrune = yamlDb.length - yamlCommon.length,
      /** The number of file entries pruned. */
      filePrune = yamlFiles.length - yamlCommon.length;

    if (filePrune > 0) {
      // First, unlink orphaned files
      for (const file of yamlFiles.filter((i) => !yamlCommon.includes(i)))
        await unlink(file);
    }

    if (dbPrune > 0) {
      // Then, deal with cleaning the database
      /** The data to be used for cleaning the database. */
      const dbCleanup: Record<string, string[]> = {};
      // first here, parse the file list
      for (const file of yamlDb
        .filter((i) => !yamlCommon.includes(i))
        .map((i) => i.split(pathSep).slice(1))) {
        if (!dbCleanup[file[0]]) dbCleanup[file[0]] = [file[1]];
        else dbCleanup[file[0]].push(file[1]);
      }
      console.debug(dbCleanup);
      // then, remove any users that don't have any files (otherwise, they wouldn't get pruned at all)
      // BUG: this currently obliterates the YAML table [possibly now fixed]
      await YamlTable.destroy({
        where: { userId: { [SqlOp.in]: Object.keys(dbCleanup) } },
      });
      // finally, remove missing entries for users
      for (const op of Object.entries(dbCleanup)) {
        await YamlTable.destroy({
          where: {
            userId: op[0],
            filename: { [SqlOp.notIn]: op[1].map((i) => basename(i, ".yaml")) },
          },
        });
      }
    }

    // finally, clear any invalid defaults
    const [defaultsAffected] = await PlayerTable.update(
      { defaultCode: null },
      {
        where: {
          defaultCode: {
            [SqlOp.notIn]: (
              await YamlTable.findAll({ attributes: ["code"] })
            ).map((i) => i.code),
          },
        },
      }
    );

    interaction?.followUp(
      `Removed ${dbPrune} DB entry/ies, and ${filePrune} orphaned file(s), and reset ${defaultsAffected} defaults.`
    );
  }

  /**
   * Determines the worst state of any single game in a given list of game names.
   * @static
   * @param games The list of games to evaluate.
   * @returns {GameFunctionState} The worst state of any single game in the list.
   */
  static GetWorstStatus(games: string[]): GameFunctionState {
    let retval: GameFunctionState = GameFunctionState.Playable;
    for (const game of games)
      retval = Math.max(retval, GetGameFunctionState(game));
    return retval;
  }

  /**
   * Determines which emoji to use for a given list of games, usually used in {@link YamlManager.GetYamlOptionsV3}.
   * @static
   * @param games The list of games to evaluate.
   * @param markDefault Whether to use the ⚔️ emoji to denote the user's default YAML.
   * @returns {string} The emoji to use for this YAML, if any.
   */
  static GetEmoji(games: string[], markDefault = false): string {
    switch (YamlManager.GetWorstStatus(games)) {
      case GameFunctionState.Playable:
        return markDefault ? "⚔️" : "";
      case GameFunctionState.Testing:
        return "🧪";
      case GameFunctionState.Broken:
        return "💔";
      case GameFunctionState.Upcoming:
        return "⏳";
      case GameFunctionState.Support:
        return "🗡️";
      case GameFunctionState.Excluded:
        return "❌";
      case GameFunctionState.Unknown:
        return "❓";
    }
  }

  /**
   * Determines the worst state of any single game in a given list of games for a four-letter YAML code.
   * @static
   * @async
   * @param code The four-letter code of the YAML to retrieve.
   * @returns {Promise<GameFunctionState>} A promise that resolves into the worst state of any single game in the list.
   *  If no YAML is found for the given code, returns {@link GameFunctionState.Unknown}.
   */
  static async GetWorstStatusByCode(code: string): Promise<GameFunctionState> {
    return YamlTable.findByPk(code).then((yaml) => {
      if (!yaml) return GameFunctionState.Unknown;
      return YamlManager.GetWorstStatus(yaml.games);
    });
  }

  /**
   * Determines which emoji to use for a given list of games for a four-letter YAML code, usually used in {@link YamlManager.GetYamlOptionsV3}.
   * @static
   * @async
   * @param code The four-letter code of the YAML to retrieve.
   * @returns {Promise<string>} A promise that resolves into the emoji to use for this YAML, if any.
   *  If no YAML is found for the given code, returns ❓.
   */
  static async GetEmojiByCode(code: string): Promise<string> {
    return YamlTable.findByPk(code).then((yaml) => {
      if (!yaml) return "❓";
      return YamlManager.GetEmoji(yaml.games);
    });
  }

  static async GetYamlVersionByCode(code: string): Promise<VersionSpec | null> {
    return YamlTable.findByPk(code)
      .then((yaml) => {
        if (!yaml) return null;
        return readFile(
          pathJoin("yamls", yaml.userId, `${yaml.filename}.yaml`)
        );
      })
      .then((file) => {
        if (!file) return null;
        const yaml = YAML.parse(file.toString());
        if (!yaml.requires || !yaml.requires.version) return null;
        return yaml.requires.version
          .split(".")
          .map((i: string) => Number.parseInt(i));
      })
      .catch(() => null);
  }
}
